#include <iostream>
#include <vector>
#include <bitset>
#include <cstdlib>

template<typename T>
void print_vec(const std::vector<T>& vec)
{
  for(auto num : vec)
  {
    std::cout << num << ", ";
  }
}

/**
 * An iterator to generate all (n choose k) subsets from a large set.
 */
class Iterator {
public:
  Iterator()
  : bits_(0),
    n_(0)
  {}

  /** Create an "n choose k" iterator.
   *
   * @param n The size of the whole set.
   * @param k The size of the subset that will be generated by GetSubset().
   */
  static Iterator Create(int n, int k) {
    Iterator iter;

    //Start with all (and only) the rightmost k bits set.
    //For instance, 00000111 for k=3.
    //We will be using all the n rightmost bits,
    //changing bits_ to change which 3 (for instance) bits are set.
    iter.bits_ = (0x01 << k) - 1;

    iter.n_ = n;

    std::cout << "n=" << iter.n_ << ", k=" << k << std::endl;
    std::cout << std::bitset<16>(iter.bits_) << std::endl;

    return iter;
  }

  /** Change the iterator to indicate the next subset.
   *
   * @result False if there are no more subsets.
   */
  bool next() {
    //A mask with all n bits unset: (1 bit unset for each possible item)
    const Byte bits_past_max = ~ ((0x01 << n_) -1); //For instance, ...111111100 for 2.

    //Gosper's Hack:
    //See https://en.wikipedia.org/wiki/Combinatorial_number_system
    const Byte u = bits_ & -bits_; // extract rightmost bit 1.
    const Byte v = u + bits_; // set last non-trailing bit 0, and clear to the right.

    if(v == 0)
      return bits_; //Overflow. Stop because we cannot represent the next combination in Byte.

    bits_ = v + (((v ^ bits_) / u) >> 2);

    //Stop when our bit mask goes past the max number of bits/items.
    //We then return an empty result.
    if((bits_ & bits_past_max))
    {
      bits_ = 0;
      return bits_;
    }

    std::cout << std::bitset<16>(bits_) << std::endl;
    return bits_;
  }

  /** Get the subset indicated by the current state of the iterator.
   *
   * @param set The whole set. This should of size n, as passed to Create().
   */
  std::vector<int> GetSubset(const std::vector<int>& set) {
    std::vector<int> result;

    //Use item i from the set if bit i is set in bits_:
    for(int i = 0; i < n_; ++i)
    {
      const Byte mask = (0x01 << i);
      if(bits_ & mask)
      {
        result.emplace_back(set[i]);
      }
    }

    return result;
  }

private:
  typedef unsigned char Byte;
  Byte bits_;
  int n_;
};

int main() {

  std::vector<int> set = {1, 2, 3, 4, 5};
  std::cout << "Whole set: ";
  print_vec(set);
  std::cout << std::endl;

  Iterator iter = Iterator::Create(set.size(), 3);
  do {
    const auto subset = iter.GetSubset(set);
    std::cout << "Subset: ";
    print_vec(subset);
    std::cout << std::endl;

  } while(iter.next());

  return EXIT_SUCCESS;
}
