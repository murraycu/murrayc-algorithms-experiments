/* Copyright (C) 2015 Murray Cumming
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/
 */

#ifndef __MURRAYC_SUBSET_ITERATOR_H
#define __MURRAYC_SUBSET_ITERATOR_H

#include <iostream>
#include <bitset>
#include <cstdlib>

/**
 * An iterator to generate all (n choose k) subsets from a large set.
 */
template <class T_container>
class SubsetIterator {
public:
  using type_container = T_container;
  using type_size = typename T_container::size_type;

  SubsetIterator()
  : bits_(0),
    n_(0),
    end_(false)
  {}

  SubsetIterator(const SubsetIterator& src) = default;
  SubsetIterator& operator=(const SubsetIterator& src) = default;

  SubsetIterator(SubsetIterator&& src) = default;
  SubsetIterator& operator=(SubsetIterator&& src) = default;

  /** create an "n choose k" iterator.
   *
   * @param n The size of the whole set.
   * @param k The size of the subset that will be generated by get_subset().
   */
  static SubsetIterator create(type_size n, type_size k) {
    SubsetIterator iter;

    //Start with all (and only) the rightmost k bits set.
    //For instance, 00000111 for k=3.
    //We will be using all the n rightmost bits,
    //changing bits_ to change which 3 (for instance) bits are set.
    iter.bits_ = (0x01 << k) - 1;

    iter.n_ = n;

    std::cout << "n=" << iter.n_ << ", k=" << k << std::endl;
    std::cout << std::bitset<16>(iter.bits_) << std::endl;

    return iter;
  }

  static SubsetIterator end() {
    SubsetIterator iter;
    iter.end_ = true;
    return iter;
  }

  SubsetIterator& operator++() {
    next();
    return *this;
  }

  bool operator==(const SubsetIterator& src) {
    return (end_ == src.end_) &&
      (bits_ == src.bits_) &&
      (n_ == src.n_);
  }

  bool operator!=(const SubsetIterator& src) {
    return !operator==(src);
  }

  /** Change the iterator to indicate the next subset.
   *
   * @result False if there are no more subsets.
   */
  bool next() {
    //A mask with all n bits unset: (1 bit unset for each possible item)
    //A single high bit would do, but this seems even more robust.
    const Byte bits_past_max = ~ ((0x01 << n_) -1); //For instance, ...111111100 for 2.

    //Gosper's Hack:
    //See https://en.wikipedia.org/wiki/Combinatorial_number_system
    const Byte u = bits_ & -bits_; // extract rightmost bit 1.
    const Byte v = u + bits_; // set last non-trailing bit 0, and clear to the right.

    if(v == 0)
      return bits_; //Overflow. Stop because we cannot represent the next combination in Byte.

    bits_ = v + (((v ^ bits_) / u) >> 2);

    //Stop when our bit mask goes past the max number of bits/items.
    //We then return an empty result.
    if((bits_ & bits_past_max))
    {
      //std::cout << "setting end_" << std::endl;
      end_ = true;
      bits_ = 0;
      n_ = 0;
      return bits_;
    }

    std::cout << std::bitset<16>(bits_) << std::endl;
    return bits_;
  }

  /** Get the subset indicated by the current state of the iterator.
   *
   * @param set The whole set. This should of size n, as passed to create().
   */
  type_container get_subset(const type_container& set) const {
    type_container result;

    //Use item i from the set if bit i is set in bits_:
    for(type_size i = 0; i < n_; ++i)
    {
      const Byte mask = (0x01 << i);
      if(bits_ & mask)
      {
        result.emplace_back(set[i]);
      }
    }

    return result;
  }

private:
  typedef unsigned char Byte;
  Byte bits_;
  type_size n_;
  bool end_;
};

#endif //__MURRAYC_SUBSET_ITERATOR_H
